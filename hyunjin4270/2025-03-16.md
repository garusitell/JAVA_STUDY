### final - 마지막의, 변경될 수 없는
변수에 사용되면 값을 변경할 수 없는 상수가 되며, 메서드에 사용되면 오버라이딩을 할 수 없게되고, 클래스에 사용되면 자신을 확장하는 자손클래스를 정의하지 못하게 된다.
- final 클래스
    - 변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.
    - final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다.
- final 메서드
    - 변경될 수 없는 메서드
    - 오버라이딩을 통해 재정의될 수 없다.
- final 변수
    - 변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.

#### 생성자를 이용한 final멤버 변수의 초기화
final이 붙은 변수는 상수이므로 일반적으로 선언과 초기화를 동시에 하지만, 인스턴스변수의 경우 생성자에서 초기화 되도록 할 수 있다.

```java
class Card {
    final int NUMBER;
    final String KIND;

    Card(String kind, int num) {
        NUMBER = num;
        KIND = kind;
    }
}
```
### abstract - 추상의, 미완성의
메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용된다.
클래스에 사용되어 클래스 내에 추상메서드가 존재한다는 것을 쉽게 알 수 있게 한다.

- abstract 클래스
    - 클래스 내에 추상 메서드가 선언되어 있음을 의미한다
- abstract 메서드
    - 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알린다.

추상 클래스는 아직 완성되지 않은 메서드가 존재하는 미완성 설계도이므로 인스턴스를 생성할 수 없다.

```java
abstract class AbstractTest {
    abstract void move();
}
```

### 접근 제어자(access modifier)
접근 제어자는 멤버 도는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.
접근 제어자는 클래스, 멤버변수, 메서드, 생성자에 쓰일 수 있다.
- private
    - 같은 클래스 내에서만 접근이 가능하다
- default
    - 같은 패키지 내에서만 접근이 가능하다
- protected
    - 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.
- public
    - 접근 제한이 없다

접근 범위가 넓은 쪽에서 좁은 순으로 나열하면 다음과 같다
public > protected > default > private

#### 접근 제어자를 이용한 캡슐화
클래스나 멤버, 주로 멤버에 접근 제어자를 사용하는 이유는 클래스의 내부에서 선언된 데이터를 보호하기 위해서다.
데이터가 유효한 값을 유지하도록, 또는 비밀번호와 같은 데이터를 외부에서 함부로 변경하지 못하도록 하기 위해서는 외부로부터 접근을 제한하는 것이 필요하다.
이를 객체지향개념의 **캡슐화**라고 한다.
또 다른 이유는 클래스 내에서만 사용되는, 내부 작업을 위해 임시로 사용되는 멤버변수나 부분작업을 처리하기 위한 메서드 등의 멤버들을 클래스 내부에서 감추기 위해서다.
외부에서 접근할 필요가 없는 멤버들을 private로 지정하여 외부에 노출시키지 않음으로써 복잡성을 줄일 수 있다. 이것 역시 캡슐화에 해당한다.

> 접근 제어자를 사용하는 이유
> - 외부로부터 데이터를 보호하기 위해서
> - 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서

#### 생성자의 접근 제어자
생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수 있다.
생성자의 접근 제어자를 private로 지정하면, 외부에서 생성자에 접근할 수 없으므로 인스턴스를 생성할 수 없게 된다.
대신 인스턴스를 생성해서 반환해주는 public메서드를 제공함으로써 외부에서 이 클래스의 인스턴스를 사용하도록 할 수 있다.

### 제어자의 조합
제어자를 조합해서 사용할 때 주의해야 할 사항에 대해 알아보자.
- 메서드에 static과 abstract를 함께 사용할 수 없다.
    - static메서드는 몸통이 있는 메서드에만 사용할 수 있기 때문이다.
- 클래스에 abstract와 final를 동시에 사용할 수 없다.
    - 클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미이고 abstract는 상속을 통해서 완성되어야 한다는 의미이므로 서로 모순된다.
- abstract메서드의 접근 제ㅔ어자가 private일 수 없다.
    - absstract메서드는 자손클래스에서 구현해주어야 하는데 접근 제어자가 private면, 자손클래스에서 접근할 수 없기 때문이다.
- 메서드에 private와 final를 같이 사용할 필요는 없다.
    - 접근 제어자가 private인 메서드는 오버라이딩될 수 없기 때문이다. 이 둘 중 하나만 사용해도 의미가 충분하다.

## 다형성
### 다형성이란?
객체지향개념에서 다형성이란, **여러 가지 형태를 가질 수 있는 능력**을 의미하며, 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현하였다.
**조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하였다.**

```java
class TV {}
class CaptionTv extends TV{}
```

지금 Tv와 CaptionTV는 서로 상속관계에 있다.
인스턴스 타입과 참조변수의 타입이 일치하는 것이 보통이지만, Tv와 CaptionTv클래스가 서로 상속관계에 있을 경우, 조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조하도록 하는것도 가능하다.

```java
TV t1 = new CaptionTV();
CaptionTV t2 = new CaptionTV();
```

위의 코드에서 CaptionTV인스턴스 2개를 생성하고, 참조변수 t1과 t2가 Caption인스턴스를 참조하도록 하였다.
TV타입의 참조변수로는 CaptionTV인스턴스 중에서 TV클래스의 멤버만 사용이 가능하다.
따라서 생성된 CaptionTV인스턴스의 멤버 중에서 TV클래스에 정의되지 않은 멤버는 t로 사용이 불가능하다.
**둘 다 같은 타입의 인스턴스지만 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다.**

반대로, 자손타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 불가능하다.
이유는 자손 타입은 조상보다 더욱 많은 기능을 가질 수 있기 때문이다.

### 참조변수의 형변환
서로 상속관계에 있는 클래스사이에서만 형변환이 가능하다.
자손타입의 참조변수를 조상타입의 참조변수로, 조상타입의 참조변수를 자손타입의 참조변수로의 형변환만 허용된다.
자손타입을 조상타입으로 형변환하는 것을 **업 캐스팅**이라 하며, 형변환 연산자를 생략할 수 있다.
바난대로, 조상타입을 자손타입으로 형변환하는 것을 **다운 캐스팅**이라 하며, 형변환을 반드시 붙여야 한다.

### instanceof
참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceof연산자를 사용한다.

```java
TV t1 = new CaptionTV();
TV t2 = new TV();

System.out.println(t1 instanceof CaptionTV); //true
System.out.println(t1 instanceof TV); //true

System.out.println(t1 instanceof CaptionTV); //false
System.out.println(t1 instanceof TV); //true
```

### 참조변수와 인스턴스의 연결
조상 클래스에 선언된 멤버변수와 같은 이름의 인스턴스변수를 자손 클래스에 중복으로 정의했을 때, 조상타입의 참조변수로 자손 인스턴스를 참조하는 경우와 자손타입의 참조변수로 자손 인스턴스를 참조하는 경우는 서로 다른 결과를 얻는다.
메서드는 실제 인스턴스의 메서드기준으로 호출이 이뤄지지만, 메서드와 달리 멤버변수의 경우 참조변수의 타입에 따라 달라진다.

멤버변수가 조상 클래스와 자손 클래스에 중복으로 정의된 경우, 조상타입의 참조변수를 사용했을 때는 조상 클래스에 선언된 멤버변수가 사용되고, 자손타입의 참조변수를 사용했을 때는 자손 클래스에 선언된 멤버변수가 사용된다.

```java
class Parent {
    String name = "Parent Name";
}

class Child extends Parent {
    String name = "Child Name";  // 같은 이름의 멤버 변수 선언
}

public class Main {
    public static void main(String[] args) {
        Parent parent = new Child();  
        System.out.println(parent.name); // "Parent Name"
    }
}
```

만약 자손 클래스의 멤버변수로 접근할려면, 다운캐스팅으로 접근해야한다.
반대로 자손 타입의 참조변수가 조상클래스의 멤버변수로 접근하는것은 쉬운데, super를 쓰면 된다.

```java
class Parent {
    String name = "Parent Name";
}

class Child extends Parent {
    String name = "Child Name";  // 같은 이름의 멤버 변수 선언

    void printNames() {
        System.out.println("자손 클래스 name: " + name);            // Child Name
        System.out.println("조상 클래스 name: " + super.name);      // Parent name
    }
}

public class Main {
    public static void main(String[] args) {
        Child child = new Child();
        child.printNames()
    }
}
```

### 여러 종류의 객체를 배열로 다루기
조상타입의 배열이 있다할 때, 다형성으로 인해 배열안의 요소를 자손타입을 넣을 수 있다.
```java
class Parent {
    String name = "Parent Name";
}

class Child extends Parent {
    String name = "Child Name";  // 같은 이름의 멤버 변수 선언

    void printNames() {
        System.out.println("자손 클래스 name: " + name);            // Child Name
        System.out.println("조상 클래스 name: " + super.name);      // Parent name
    }
}

public class Main {
    public static void main(String[] args) {
        Parent[] arr = new Parent[3];
        
        Parent parent = new Child();
        arr[0] = parent;

        Child child = new Child();
        arr[1] = child;
    }
}
```

## 추상클래스
### 추상클래스란?
추상클래스를 빗대어 설명하면, 미완성 설계도에 비유할 수 있다.
추상클래스 자체로는 클래스로서의 역할을 다 못하지만 새로운 클래스를 작성하는데 있어서 바탕이 되는 조상클래스로서 중요한 의미를 갖는다.
새로운 클래스를 작성할 때 아무 것도 없는 상태에서 시작하는 것 보다, 공통된 특징을 가진 클래스의 특징을 묶어 추상클래스고 틀을 맞춘 상태에서 시작한다는 것에 큰 의의가 있다.

```java
abstract class name {}
```

### 추상메서드
메서드는 선언부와 구현부로 구성되어 있다.
하지만 추상메서드는 선언부만 작성하고, 구현부는 작성하지 않는다.
이런의미에서 미완성이라 불리는데, 이러한 추상메서드를 상속받은 자식클래스에서 이 추상메서드를 오버라이딩해 추상메서드의 구현부를 작성한다.

```java
abstract void methodName();
```

### 추상클래스의 작성
상속이 자손 클래스를 만드는데 조상 클래스를 사용하는 것이라면, 이와 반대로 추상화는 기존 클래스의 공통부분을 뽑아내서 조상 클래스를 만드는 것이라고 할 수 있다.
상속 계층도를 따라 내려갈수록 클래스는 점점 기능이 추가되어 구체화의 정도가 심해지며, 상속 계층도를 따라 올라갈수록 클래스는 추상화의 정도가 심해진다고 할 수 있다.

- **추상화**
    - 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업
- **구체화**
    - 상속을 통해 클래스를 구현, 확장하는 작업

```java
abstract class Unit {
int x, y;
abstract void move(int x, int y);
void stop () { / * 현재 위치에 정지 */ }
}

class Marine extends Unit { // 보병
void move(int x, int y) { /* 지정된 위치로 이동 */ }
void stimPack() { /* 스팀팩을 사용한다. */ }
}

class Tank extends Unit { // 탱크
void move(int x, int y)
void changeMode ()
{ /* 지정된 위치로 이동 */ }
{ /* 공격모드를 변환한다. */}
}

class Dropship extends Unit {// 수송선
void move(int x, int y) { /* 지정된 위치로 이동 */ }
void load() { /* 선택된 대상을 태운다. */}
void unload() { /* 선택된 대상을 내린다. */}
}
```

위에있는 코드를 예로 들어보자면, 보병과 탱크, 수송선의 공통된 특징을 묶어 추상클래스를 구현했다. 
이러한 과정을 추상화라고 하며, 이를 상속받아 클래스들 만의 각색을 담으며 구현하는 것을 구체화라고 한다.

## 인터페이스
### 인터페이스란?
인터페이스는 추상클래스처럼 추상메서드를 가지지만, 추상클래스보다 추상화 정도가 높아 추상클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다.
오직 추상메서드와 상수만을 멤버로 가질 수 있으며, 그 외에 어떠한 요소도 허용하지 않는다.
추상클래스를 미완성 설계도로 빗대었다면, 인터페이스를 밑그림만 그려져있는 기본 설계도라 할 수 있다.

```java
interface InterfaceName {
    int valueName = 1;
    methodName();
}
```

앞선 설명에서 추상메서드와 상수만을 멤버로 가질 수 있다 했는데, 위의 코드는 상수가 아닌 변수와 추상메서드가 아닌 메서드다.
그 이유는 생략이 가능하기 때문이다.

- 모든 멤버변수는 public static final이어야 하며, 이를 생략할 수 있다.
- 모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다.

### 인터페이스의 상속
인터페이스는 인터페이스로부터만 상속받을 수 있으며, 클래스와는 달리 다중상속이 가능하다

```java
interface Movable {}
interface Attackable {}
interface Fightable extends Movable, Attackable {}
```

### 인터페이스의 구현
추상클래스가 상속을 통해 추상메서드의 구현부를 만드는 것 처럼, 인터페이스도 자신에 정의된 추상메서드의 구현부를 만들어주는 클래스를 작성해야 하는데, 그방법은 추상클래스가 자신을 상속받는 클래스와 비슷하다.
인터페이스를 상속받기 위해선 키워드 **extends** 대신, **implements**를 사용해야 한다.

```java
class Fighter implements Fightable {

}
```

만일 구현하는 인터페이스의 메서드 중 일부만 구현한다면, abstract를 붙여서 추상클래스로 선언해야 한다.

```java
abstract class Fighter implements Fightable {

}
```

그리고 상속과 구현을 동시에 할 수 있다.

```java
class Fighter extends Unit implements Fightable {

}
```

### 인터페이스를 이용한 다형성
인터페이스를 이용한 다형성 또한 가능하다.
인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있으며, 인터페이스 타입으로의 형변환 또한 가능하다.

```java
Fightable f = new Fighter();
```

따라서 인터페이스는 매개변수 타입으로서 활용 또한 가능하다.

```java
void attack(Fightable f) {}
```

### 인터페이스의 장점
- 개발시간을 단축할 수 있다.
    - 인터페이스가 작성되면 ,이를 사용해서 프로그램을 작성하는 것이 가능하다. 메서드를 호출하는 쪽에서는 메서드의 내용에 관계없이 선언부만 알면 되기 때문이다.
- 표준화가 가능하다
    - 프로젝트에 사용되는 기본 틀을 인터페이스로 작성한 다음, 개발자들에게 인터페이스를 구현하여 프로그램을 작성함 으로써 보다 일관되고 정형화된 프로그램의 개발이 가능하다.
- 서로 관계없는 클래스들에게 관계를 맺어줄 수 있다.
    - 이는 다형성의 최대 장점을 살릴 수 있는 크나큰 장점 중 하나다.
- 독립적인 프로그래밍이 가능하다.
    - 인터페이스를 이용하면 클래스의 선언과 구현을 분리시킬 수 있기 때문에 실제구현에 독립적인 프로그램을 작성하는 것이 가능하다. 클래스와 클래스간의 직접적인 관계를 인터페이스를 이용해서 간접적인 관계로 변경하면, 한 클래스의 변경이 관련된 다른 클래스에 영향을 미치지 않는 독립적인 프로그래밍이 가능하다.

#### 디폴트 메서드
인터페이스에 메서드를 추가한다는 것은 추상 메서드를 추가한다는 것이고, 이 인터페이스를 구현한 기존의 모든 클래스들이 새로 추가된 메서드를 구현해야하기 때문이다.
디폴트 메서드는 추상 메서드의 기본적인 구현을 제공하는 메서드로, 추상메서드가 아니기 때문에 디폴트 메서드가 새로 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 된다.
디폴트 메서드는 앞에 키워드 default를 붙여야하며, 구현부가 있어야 한다. 디폴트 메서드 역시 public이며, 생략이 가능하다.

```java
interface Interface {
    void method();
    default void newMethod() {}
}
```

### 내부 클래스 (inner class)
내부 클래스는 클래스 내에 선언된 클래스다.
한 클래스를 다른 클래스의 내부 클래스로 선언하면 두 클래스의 멤버들 간에 서로 쉽게 접근할 수 있다는 장점과 외부에는 불필요한 클래스를 감춤으로써 코드의 복잡성을 줄일 수 있다.

### 내부클래스의 종류와 특징
- 인스턴스 클래스
    - 외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 인스턴스멤버처럼 다뤄진다.
- static 클래스
    - 외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 static멤버처럼 다뤄진다.
- 지역 클래스
    - 외부 클래스의 메서드나 초기화블럭 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다.
- 익명 클래스
    - 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스다. 일회용이다.

### 익명클래스 (anonymous class)
익명 클래스는 내부클래스와 달리 이름이 없다.
클래스의 선언과 객체의 생성을 동시에 하기 때문에 단 한번만 사용될 수 있고 오직 하나의 객체만을 생성할 수 있는 일회용 클래스다.

```java
class Inner {
    Object iv = new Object() { void method(){} };
    static Object cv = new Object() { void method(){} };

    void myMethod() {
        Object lv = new Object() { void method(){} };
    }
}
```

