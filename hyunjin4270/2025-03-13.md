# 제어문
제어문 : 프로그램의 흐름을 바꾸는 역할을 하는 문장
제어문에는 조건문과 반복문이 있다.

조건문 : 조건에 따라 수행되는 문장
반복문 : 특정 문장들을 반복해서 수행하는 문장

## 조건문 - if, switch
조건문은 if문과 switch문, 두 가지가 있으며, if문이 더욱 많이 쓰인다.

### if문
if문은 가장 기본적인 조건문이며, 조건식은 불리언(boolean) 값이 반드시 와야한다.

```java
if (/*조건식*/) {
    // 조건식이 참 이라면, 다음 블록을 실행
}
```

다른 동적 프로그래밍 언어(Python, Javascript 등)와 같은 경우 조건식이 얕은 비교로 truthy, falsy한 값이 오면 자동으로 보정해주지만,
Java와 같은 경우 강한 정적 타입 비교 언어라, 만약 조건식에 불리언 값이 오지 않으면 컴파일 에러가 발생하게 된다.

#### if - else 문

```java
if (false) {
    System.out.println("출력 x");
} else {
    System.out.println("출력 o");
}
```

else문은 앞선 조건문이 모두 false라면 실행되는 문장이다.

### if - else if 문

```java
if (false) {
    System.out.println("출력 x");
} else if (true) {
    System.out.println("출력 o");
}
```

else if문은 앞선 조건문이 false라면, 조건식이 true인지 검사한다. 만약 true라면 스코프 안에 있는 코드를 실행한다.
여기서 만약 true라면, 뒤에있는 else-if문은 모두 건너뛰기 때문에 else if문의 순서도 중요하다.

### if문과 if-else문

```java
if(x < 0) {

}
if(x < 1) {

}
if(x < 2) {

}
```
```java
if(x < 0) {

}else if(x < 1) {

}else if(x < 2) {

}
```

위의 코드는 if문만 넣었고, 아래의 코드는 else-if문을 섞었다. 여기서 중요한건 엄연히 구동방식이 다르다는 것이다.
위의 코드는 만약 x가 0이면, 2번째와 3번째 구문이 true값이면서 블록안에있는 코드를 작동시키지만,
아래에 있는 코드는 만약 x가 0일때, 1번째 else if문 안에있는 블록을 작동시키고 그 다음 else if문을 건너뛴다.


### switch문

```java
switch (/*조건식*/) {
    case 1:
        break;
    case 2:
        break;
    case 3:
        break;
    default:
        break;
}
```

if문과는 다른 생김새의 조건문이다. if문과 다른 점은 조건식의 값이 boolean값이 아니여도 된다는 것이다.
조건문의 값이 case문 앞에 있는 값과 동일하면, case문의 블록 내에있는 코드를 실행하고, 만약 동일한 case문이 없으면
default문 안에있는 코드를 실행한다.
switch문은 모든 case문과 defalut문 마다 break문을 넣어야되기 때문에 불편해, 많은 개발자들이 if문보다 많이 쓰진 않는다.
하지만 이를 느낀 oracle은 Java14부터 이 switch문을 향상시켜 이용하기 편하게 만들었다.
```java
switch (/*조건식*/) {
    case 1 ->
    case 2 ->
    case 3 ->
    default ->
}
```

이러한 생김새를 가진 switch문은 모든 case문과 default문에 break문을 넣지 않아도되기때문에 기존에 쓰이는 switch문보다 가독성이 좋아진다.

## 반복문 - for, while, do-while
반복문은 조건문에 기능을 더한것이라 생각하면 된다.
만약 조건식이 참이라면, 블록 안에있는 코드를 실행하고, 블록안에있는 코드를 모두 실행하면, 다시 코드 위로 올라와 조건식이 참인지 검사한다.

### for문
```java
    for(/*초기화*/;/*조건식*/;/*증감식*/) {

    }
```

for문의 생김새는 소괄호 안에 변수의 초기화, 조건식, 변수의 증감식이 있다.
저기서 for문의 초기화, 조건식, 증감식을 생략할 수 있으며, 만약 조건식이 생략되어있으면 true로 간주해 무한루프로 동작한다.
작동순서는 변수의 초기화가 우선이고, 조건식을 검사하여 결과가 참이면 코드 블럭 내에있는 코드를 실행하고, 모두 실행하면 증감식을 실행한다.
이후로 초기화는 이루어지지 않으며 조건식 검사->블록 내 코드 실행->증감식 실행 이 반복된다.

### 향상된 for문
```java
for(/*타입 변수 명*/ : /*배열 또는 컬렉션*/) {

}
```

향상된 for문이다. 배열 또는 컬렉션의 요소 0번부터 마지막 요소까지 차례대로 변수에 저장한다. 이는 모든 배열을 순회할 때 많이 쓰이는 for문이다.

### while문
```java
while (/*조건식*/) {

}
```

앞선 for문보다 간단한 형태를 띄고 있다. 주로 무한반복문을 구현할 때 많이 쓰인다.

### do-while문
```java
do {

} while (/*조건식*/);
```

do-while문은 **조건식에 대한 검사가 블록 내 코드가 끝나고 이루어진다.** 이건 한번 뿐만 아니라 다음 반복에서도 마찬가지로,
블럭 내 모든 코드를 읽고 while문의 조건식을 검사한다.

### break, continue문
break문은 **블럭 내 구문이 속해있는 가장 가까운 반복문을 탈출한다.** continue문은 break문 과 비슷하게 **블럭 내 구문이 속해있는 가장 가까운 반복문을 다시한다.**
반복문에 이름을 붙이고, break, continue문 뒤에 이름을 붙이면 해당 이름을 가진 반복문에 영향을 준다.

```java
Loop1 : for(int i = 2; i <= 9;i++) {
    for(int j = 1; j <= 9; j++) {
        if(j == 5) break Loop1;
    }
}
```

# 자바를 시작하기 전에
자바는 썬 마이크로시스템즈에서 만든 객체지향 프로그래밍 언어다.
중요한 득징은 운영체제가 독립적(JVM)이라는 것이다. 자바로 작성된 프로그램은 운영체제의 종류에 관계없이 실행이 가능하기 때문에, 운영체제에 따라 프로그램을 변경안해도 된다.
C++의 장점을 채택하는 동시에 잘 사용하지 않는 부분은 제외시킴으로써 비교적 배우기 쉽고 이해하기 쉬운 간결한 표현이 가능하도록 했다.
풍부한 클래스 라이브러리를 통해 프로그래밍에 필요한 요소들을 기본적으로 제공하기 때문에 자바 프로그래머는 단순히 라이브러리를 활용하는 것만해도 강력한 기능의 자바 프로그램을 작성할 수 있다.

### 자바의 역사
- 1991년 썬의 엔지니어들에 의해서 고안된 Oak 언어
- 제임스 고슬링과 아서 밴 호프와 같은 개발자가 가전제품에 탑제될 목적으로 개발
- 이후로 Oak를 Java로 개명

### 특징
- 운영체제가 독립적이다
    - JVM이 자바 응용프로그램으로부터 전달받은 명령을 해당 운영체제가 이해할 수 있도록 변환하여 전달한다.
    - 자바로 작성된 프로그램은 운영체제에 독립적이다.
- 객체지향언어
    - 객체지향개념의 특징인 상속, 캡슐화, 다형성이 잘 적용된 순수한 객체지향언어
- 배우기 쉽다
    - 기본구문은 C++에서, 객체지향관련 구문은 스몰톡이라는 객체지향언어에서 가져옴
    - 기존에 있던 객체지향언어의 특징 때문에 배우기 어려워 사용자층 확보가 안됐으나, 간결하면서도 명료한 객체지향적 설계로 이에 대해 이해하기가 쉬움
- 자동 메모리 관리
    - 가비지컬렉터로 사용되지 않는 메모리를 정리해준다
- 네트워크와 분산처리를 지원한다
    - 다양한 네트워크 프로그래밍 라이브러리(Java API)를 통해 짧은 시간에 네트워크 관련 프로그램을 쉽게 개발이 가능하다
- 멀티쓰레드를 지원한다.
- 동적 로딩을 지원한다
    - 실행 시에 모든 클래스가 로딩되지 않고 필요한 시점에 클래스를 로딩하여 사용할 수 있다는 장점이 있다.

## JVM
자바로 작성된 애플리케이션은 모두 이 JVM에서만 실행되기 때문에, 자바 애플리케이션이 실행되기 위해서는 반드시 JVM이 필요하다.
하지만 하드웨어에 맞게 완전히 컴파일된 상태가 아니고 실행 시에 해석되기 때문에 속도가 느리다는 단점이 있다.

## JDK 설치하기
JDK는 자바 가상머신과 자바클래스 라이브러리 외에 자바를 개발하는데 필요한 프로그램을 설치할 수 있는 툴이다.
JDK의 bin 디렉토리에 있는 주요 실행파일들은 다음과 같다
- javac.exe : 자바 컴파일러, 자바소스코드를 바이트코드로 컴파일한다
- java.exe : 자바 인터프리터, 컴파일러가 생성한 바이트코드를 해석하고 실행한다
- javap.exe 역어셈블러, 컴파일된 클래스파일을 원래의 소스로 변환한다.

Hello.java 라는 자바파일이 있다면, javac.exe을 이용해 컴파일하여 Hello.class라는 자바 인터프리터가 만들어진다.
이제 java.exe를 이용해 이 Hello.class라는 자바 인터프리터를 실행할 수 있다.

## Hello world
자바의 첫 시작은 psvm호출이다.
```java
public static void main(String[] args)
```

저기서 예약어들의 역할은 이렇다.

- public(공개 접근 제한자) : JVM이 어디서든 호출할 수 있도록 함
- static(인스턴스 생성 없이 실행) : java.exe가 main을 호출할 때 객체를 만들 필요 없음
- void(반환값 없음) : main()은 실행만 하고 값을 돌려주지 않음
- main(고정된 메서드 이름) : Java는 main()에서 실행 시작
- String[] args(명령줄 인자 전달) : 사용자가 전달하는 데이터를 저장함

이 중에서 무엇하나 빠지면 자바를 실행시킬 수 없다. 여기서 String[] args는 입력이 없으면 실행 가능하지 않나? 라고 의문을 품을 수 있지만,
JVM은 main(String[] args)라는 정확한 시그니처를 찾기 때문에 인자가 다르면 실행할 수 없다.

## 자바 프로그램의 실행 과정
```
c:\jdj1.8\work\java Hello
```
콘솔에서 위와 같이 Java 애플리케이션을 실행시켰을 때, 내부적인 진행 순서는 다음과 같다.
1. 프로그램의 실행에 필요한 클래스(*.class)를 로드한다.
2. 클래스파일을 검사한다.(파일형식, 악성코드 체크)
3. 지정된 클래스(Hello)에서 main(String[] args)를 호출한다.

main메서드의 첫 줄부터 코드가 실행되기 시작하여 마지막 코드까지 모두 실행되면 프로그램이 종료되고, 프로그램에서 사용했던 자원들을 모두 반환한다.


# 배열
같은 타입의 여러 변수를 하나의 묶음으로 다루는 것을 배열이라고 한다. 
중요한점은 같은 타입 이어야 한다는 것이며, 서로 다른 타입들의 변수들로 구성된 배열은 만들 수가 없다.

```java
int[] score;
int score[];
```

#### 배열의 생성
배열은 참조형이기 때문에, new 키워드를 이용해 객체를 생성해야 한다.
```java
int[] score = new int[];
```

### 배열의 초기화
**배열은 생성과 동시에 자동적으로 자신의 타입에 해당하는 기본값으로 초기화**가 이루어진다.
원하는 값을 저장할려면 아래와 같이 해줘야 한다.
```java
int[] score = new int[5];
score[0] = 50;
score[1] = 60;

int[] score = new int[] {50, 60, 70, 80, 90};
```

### 배열의 복사
배열안에 있는 요소를 복사할 때, 하나하나 접근하여 복사를 해야되지만, System.arraycopy()를 이용해 배열을 복사할 수 있다.
이는 반복문을 사용해 배열의 하나하나 접근하는 것보다 빠르게 처리하기에, 더욱 효율적이다.

## 다차원 배열
배열안에 배열을 만들 수 있다. 메모리의 용량이 충분하는 한, 차원의 제한은 없다. 보통은 1, 2차원 배열을 이용한다.
```java
int[][] score;
```

### 2차원 배열의 초기화
```java
int[][] arr = new int[][] {
    {1, 2, 3}, 
    {4, 5, 6}
    };
```

### 가변 배열
2차원 이상의 다차원 배열을 생성할 때 전체 배열 차수 중 마지막 차수의 길이를 지정하지 않고, 추후에 각기 다른 길이의 배열을 생성함으로서 고정된 형태가 아닌 보다 유동적인 가변배열을 구현이 가능하다.

```java
int[][] score = new int[5][];
score[0] = new int[4];
score[1] = new int[3];
score[2] = new int[2];
score[3] = new int[5];
score[4] = new int[7];
```